# GetLearnerPreds.pl takes one or more .sum files as its input, and collects# the predicted ratings, etc. for the wug verbs tested in the English Wug Test# experiment, ready to merge into, for example, the Exp2Ratings.txt file## the reason that this file is useful is that it weeds out duplicate and# unnecessary outputs, keeping only the best way to derive each desired output## the desired outputs are kept hardwired in a hash table, initialized in a subroutineinitarrays();print "Choose an option:\n\t(1) process individual file\n\t(2) process .bat file\n? ";$mode = <STDIN>;chomp($mode);while (!$stop){    if ($mode == 1) {	# ask user to enter the filename and process it	print "Please enter name of .sum file: ";	$inputfile = <STDIN>;	readfile();		$stop = true;        } elsif ($mode == 2) {	# ask user to enter the .bat filename and process it	print "Please enter name of batch file: ";	$batchfile = <STDIN>;	readbatch();	$stop = true;        } else {	print "Sorry, I couldn't understand you.  Please try again.\n? ";        }   }print ("Enter name for output file: ");$outputfile = <STDIN>;chomp($outputfile);open( OUTPUTFILE, ">$outputfile") or die "Can't open output file: $!\n";# first write the header lineprintf OUTPUTFILE "number\tverb\treg past\t";# we'll output just the predicted ratings on the left, then fuller infos on the rightforeach $input (sort keys %inputs) {    printf OUTPUTFILE "$input reg rating\t";}printf OUTPUTFILE "\tirreg past\t";foreach $input (sort keys %inputs) {    printf OUTPUTFILE "$input irreg rating\t";}#now the fuller infosprintf OUTPUTFILE "\tnumber\tverb\treg past\t";# we'll list the reg infos firstforeach $input (sort keys %inputs) {    printf OUTPUTFILE "$input reg rating\t$input reg island\t$input reg hits\t$input reg scope\t$input reg impugnor\t";}# a blank column before the irregsprintf OUTPUTFILE "\tirreg past\t";# and then the irreg infosforeach $input (sort keys %inputs) {    printf OUTPUTFILE "$input irreg rating\t$input irreg island\t$input irreg hits\t$input irreg scope\t$input irreg impugnor\t";}printf OUTPUTFILE "\r";# now go through the verbs and output the info, in orderforeach $number (sort keys %verb_order ){    if ($verb_order{$number} ne "")    {        	$verb = $verb_order{$number};	$reg_past = $verb_pasts{$number}[0];	$irreg_past = $verb_pasts{$number}[1];    		# first just the ratings, for doing correlations	printf OUTPUTFILE "$number\t$verb\t$reg_past\t";	# first the regs	foreach $input (sort keys %inputs) {	    printf OUTPUTFILE "$ratings{$input}{$reg_past}\t";	    	}	# the blank column	printf OUTPUTFILE "\t$irreg_past\t";		# and the irreg numbers	foreach $input (sort keys %inputs) {	    if ($ratings{$input}{$irreg_past} == "")	    {		$ratings{$input}{$irreg_past} = 0;			    }	    	    printf OUTPUTFILE "$ratings{$input}{$irreg_past}\t";	    	}		# and now the fuller infos	printf OUTPUTFILE "\t$number\t$verb\t$reg_past\t";	# first the regs	foreach $input (sort keys %inputs) {	    printf OUTPUTFILE "$ratings{$input}{$reg_past}\t$islands{$input}{$reg_past}\t$hits{$input}{$reg_past}\t$scope{$input}{$reg_past}\t$impugners{$input}{$reg_past}\t";	}	# the blank column	printf OUTPUTFILE "\t$irreg_past\t";		# and the irreg numbers	foreach $input (sort keys %inputs) {	    if ($ratings{$input}{$irreg_past} == "")	    {		$ratings{$input}{$irreg_past} = 0;			    }	    	    printf OUTPUTFILE "$ratings{$input}{$irreg_past}\t$islands{$input}{$irreg_past}\t$hits{$input}{$irreg_past}\t$scope{$input}{$irreg_past}\t$impugners{$input}{$irreg_past}\t";	}			printf OUTPUTFILE "\r";    } else {	printf OUTPUTFILE "null\r";    }        }close(OUTPUTFILE);MacPerl::SetFileInfo("XCEL", "TEXT", $outputfile);# end of main routine# now some subroutinessub initarrays {    # verbs to get keeps all the verbs we need        $verbs_to_get =  " gr»El/gr»Eld l»Qn/l»Qnd m»’n/m»’nd S»’n/S»’nd sk»Ol/sk»Old sk»El/sk»Eld skw»Il/skw»Ild sn»El/sn»Eld k»Iv/k»Ivd l»√m/l»√md p»√m/p»√md S»i/S»id z»e/z»ed b»Yz/b»Yzd d»Yz/d»Yzd dr»Ys/dr»Yst fl»IJ/fl»IJd fr»o/fr»od g»er/g»erd gl»Ip/gl»Ipt r»Yf/r»Yft st»In/st»Ind st»Ip/st»Ipt bl»Ig/bl»Igd C»ek/C»ekt dr»It/dr»It´d fl»ip/fl»ipt gl»id/gl»id´d gl»It/gl»It´d kw»id/kw»id´d pl»Im/pl»Imd skr»Yd/skr»Yd´d spl»IN/spl»INd t»ip/t»ipt g»ud/g»ud´d n»√N/n»√Nd p»QNk/p»QNkt pr»ik/pr»ikt r»Qsk/r»Qskt S»Ilk/S»Ilkt t»ark/t»arkt t»√Nk/t»√Nkt tr»Isk/tr»Iskt bl»ef/bl»eft br»EJ/br»EJd C»ul/C»uld d»ep/d»ept g»Ez/g»Ezd n»es/n»est sp»Qk/sp»Qkt st»Yr/st»Yrd t»ES/t»ESt w»Is/w»Ist n»old/n»old´d fl»Et/fl»Et´d gr»Ynt/gr»Ynt´d r»Ynt/r»Ynt´d S»Ynt/S»Ynt´d C»Ynd/C»Ynd´d gr»El/gr»Elt l»Qn/l»Qnt m»’n/m»’nt S»’n/S»’nt sk»Ol/sk»Olt sk»El/sk»Elt skw»Il/skw»Ilt sn»El/sn»Elt sn»El/sn»old k»Iv/k»ev l»√m/l»em p»√m/p»em S»i/S»ç z»e/z»Ed b»Yz/b»oz d»Yz/d»oz dr»Ys/dr»os fl»IJ/fl»√J fr»o/fr»u g»er/g»or gl»Ip/gl»√p r»Yf/r»of st»In/st»√n st»Ip/st»√p bl»Ig/bl»√g C»ek/C»Uk dr»It/dr»It fl»ip/fl»Ept gl»id/gl»Ed gl»It/gl»It kw»id/kw»Ed pl»Im/pl»√m skr»Yd/skr»od spl»IN/spl»√N t»ip/t»Ept g»ud/g»ud n»old/n»Eld n»√N/n»QN p»QNk/p»√Nk pr»ik/pr»ok r»Qsk/r»√sk S»Ilk/S»Qlk t»ark/t»ork t»√Nk/t»QNk tr»Isk/tr»Qsk bl»ef/bl»Eft br»EJ/br»oJ C»ul/C»ol d»ep/d»Qpt g»Ez/g»az n»es/n»os sp»Qk/sp»√k st»Yr/st»or t»ES/t»aS w»Is/w»√s n»old/n»old r»Yf/r»If st»In/st»Qn dr»It/dr»Qt gl»It/gl»Qt pl»Im/pl»Qm skr»Yd/skr»Id spl»IN/spl»QN pr»ik/pr»Ek tr»Isk/tr»√sk C»Ynd/C»Wnd fl»Et/fl»Et gr»Ynt/gr»ont r»Ynt/r»ont S»Ynt/S»ont C»Ynd/C»Ynd gr»Ynt/gr»Wnt r»Ynt/r»Wnt S»Ynt/S»Wnt ";    # the list that keeps track of the order of verbs we need     %verb_order = (1 => "gr»El",   2 => "l»Qn",   3 => "m»’n",   4 => "S»’n",    	5 => "sk»Ol",   6 => "sk»El",   7 => "skw»Il",   8 => "sn»El",    	9 => "sn»El",   10 => "k»Iv",   11 => "l»√m",   12 => "p»√m",    	13 => "S»i",   14 => "z»e",   15 => "b»Yz",   16 => "d»Yz",    	17 => "dr»Ys",   18 => "fl»IJ",   19 => "fr»o",   20 => "g»er",    	21 => "gl»Ip",   22 => "r»Yf",   23 => "st»In",   24 => "st»Ip",    	25 => "bl»Ig",   26 => "C»ek",   27 => "dr»It",   28 => "fl»ip",    	29 => "gl»id",   30 => "gl»It",   31 => "kw»id",   32 => "pl»Im",    	33 => "skr»Yd",   34 => "spl»IN",   35 => "t»ip",   36 => "g»ud",    	37 => "n»old",   38 => "n»√N",   39 => "p»QNk",   40 => "pr»ik",    	41 => "r»Qsk",   42 => "S»Ilk",   43 => "t»ark",   44 => "t»√Nk",    	45 => "tr»Isk",   46 => "bl»ef",   47 => "br»EJ",   48 => "C»ul",    	49 => "d»ep",   50 => "g»Ez",   52 => "n»es",   53 => "sp»Qk",    	54 => "st»Yr",   55 => "t»ES",   56 => "w»Is",   57 => "n»old",    	58 => "r»Yf",   59 => "st»In",   60 => "dr»It",   61 => "gl»It",    	62 => "pl»Im",   63 => "skr»Yd",   64 => "spl»IN",   65 => "pr»ik",    	66 => "tr»Isk",   67 => "C»Ynd",   68 => "fl»Et",   69 => "gr»Ynt",    	70 => "r»Ynt",   71 => "S»Ynt",   72 => "C»Ynd",   73 => "gr»Ynt",    	74 => "r»Ynt",   75 => "S»Ynt", 76 => "gl»id" );    %verb_pasts = (1 => ["gr»Eld", "gr»Elt"], 2 => ["l»Qnd", "l»Qnt"], 3 => ["m»’nd", "m»’nt"], 	4 => ["S»’nd", "S»’nt"], 5 => ["sk»Old", "sk»Olt"], 6 => ["sk»Eld", "sk»Elt"], 	7 => ["skw»Ild", "skw»Ilt"], 8 => ["sn»Eld", "sn»Elt"], 9 => ["", "sn»old"], 	10 => ["k»Ivd", "k»ev"], 11 => ["l»√md", "l»em"], 12 => ["p»√md", "p»em"], 	13 => ["S»id", "S»ç"], 14 => ["z»ed", "z»Ed"], 15 => ["b»Yzd", "b»oz"], 	16 => ["d»Yzd", "d»oz"], 17 => ["dr»Yst", "dr»os"], 18 => ["fl»IJd", "fl»√J"], 	19 => ["fr»od", "fr»u"], 20 => ["g»erd", "g»or"], 21 => ["gl»Ipt", "gl»√p"], 	22 => ["r»Yft", "r»of"], 23 => ["st»Ind", "st»√n"], 24 => ["st»Ipt", "st»√p"], 	25 => ["bl»Igd", "bl»√g"], 26 => ["C»ekt", "C»Uk"], 27 => ["dr»It´d", "dr»It"], 	28 => ["fl»ipt", "fl»Ept"], 29 => ["gl»id´d", "gl»Ed"], 30 => ["gl»It´d", "gl»It"], 	31 => ["kw»id´d", "kw»Ed"], 32 => ["pl»Imd", "pl»√m"], 33 => ["skr»Yd´d", "skr»od"], 	34 => ["spl»INd", "spl»√N"], 35 => ["t»ipt", "t»Ept"], 36 => ["g»ud´d", "g»ud"], 	37 => ["", "n»Eld"], 38 => ["n»√Nd", "n»QN"], 39 => ["p»QNkt", "p»√Nk"], 	40 => ["pr»ikt", "pr»ok"], 41 => ["r»Qskt", "r»√sk"], 42 => ["S»Ilkt", "S»Qlk"], 	43 => ["t»arkt", "t»ork"], 44 => ["t»√Nkt", "t»QNk"], 45 => ["tr»Iskt", "tr»Qsk"], 	46 => ["bl»eft", "bl»Eft"], 47 => ["br»EJd", "br»oJ"], 48 => ["C»uld", "C»ol"], 	49 => ["d»ept", "d»Qpt"], 50 => ["g»Ezd", "g»az"], 52 => ["n»est", "n»os"], 	53 => ["sp»Qkt", "sp»√k"], 54 => ["st»Yrd", "st»or"], 55 => ["t»ESt", "t»aS"], 	56 => ["w»Ist", "w»√s"], 57 => ["n»old´d", "n»old"], 58 => ["", "r»If"], 	59 => ["", "st»Qn"], 60 => ["", "dr»Qt"], 61 => ["", "gl»Qt"], 	62 => ["", "pl»Qm"], 63 => ["", "skr»Id"], 64 => ["", "spl»QN"], 	65 => ["", "pr»Ek"], 66 => ["", "tr»√sk"], 67 => ["", "C»Wnd"], 	68 => ["fl»Et´d", "fl»Et"], 69 => ["gr»Ynt´d", "gr»ont"], 70 => ["r»Ynt´d", "r»ont"], 	71 => ["S»Ynt´d", "S»ont"], 72 => ["C»Ynd´d", "C»Ynd"], 73 => ["", "gr»Wnt"], 	74 => ["", "r»Wnt"], 75 => ["", "S»Wnt"], 76 => ["", "gl»id"],  );  }sub readfile {    chomp($inputfile);    $input = $inputfile;    $input =~ s/.sum$//;    $inputs{$input} = 1;        open( INPUTFILE, "<$inputfile") or die "Can't open input file $inputfile: $!\n";    print "reading input file: $inputfile\n";        # the first line is the headers -- ignore it         $line = <INPUTFILE>;        # now comes the juicy part    while ($line = <INPUTFILE>)    {        chomp($line);	# each line contains a whole mess o' fields	($form, $pattern, $output, $mcat1, undef, $mcat2, undef, $A, undef, $B, $Change, 	  undef, $Pres, $Pfeat, $P, undef, $Q, $Qfeat, $Qres, $doppel, $scope, $typefreq, 	  $tokenfreq, $rel_tokenfreq, $overall, $wbf, $wbl, $c75, $c90, $c95, $i75, $i90, 	  $i95, $constraint, $related_forms, $exceptions, $impugner, $iScope, $iHits, $impugner_info, $impugner_constraint, @rest)	   = split ("\t", $line);	  	$currentverb = "$mcat1/$mcat2";	$replace = 0;		if ( $verbs_to_get =~ /\s$currentverb\s/s)	{	    if ($overall > $ratings{$input}{$mcat2})	    {	        $replace = true;	    } elsif ( $overall eq $ratings{$input}{$mcat2}) {	        if ($B eq "d")		{		    $replace = true;		} 			    }	    	    if ( $replace )	    {			        $ratings{$input}{$mcat2} = $overall;		$islands{$input}{$mcat2} = "$A -> $B / $Pres $Pfeat $P ___ $Q $Qfeat $Qres";		$impugners{$input}{$mcat2} = $impugner_constraint;		$hits{$input}{$mcat2} = $typefreq;		$scope{$input}{$mcat2} = $scope;#		print "Getting info for $currentverb\n";			    }	} else {#	    print "$currentverb isn't one we're looking for\n";	}    }        close(INPUTFILE);}sub readbatch(){    chomp ($batchfile);    open (BATCHFILE, "<$batchfile") or die "Can't open batch file: $!\n";        while ($line = <BATCHFILE>)    {		chomp($line);		($sumfile, $c, $i) = split( "\t", $line);	$sumfile =~ s/.in$//;	$inputfile = $sumfile . "_c" . $c . "i" . $i . ".sum";			readfile();	    }    }